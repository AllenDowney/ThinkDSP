# One of the major applications of the DCT is compression for both sound and images.
# In its simplest form, DCT-based compression works like this:
# * Break a long signal into segments.
# * Compute the DCT of each segment.
# * Identify frequency components with amplitudes so low they are inaudible, and remove them. Store only the frequencies and amplitudes that remain.
# * To play back the signal, load the frequencies and amplitudes for each segment and apply the inverse DCT. 
# Implement a version of this algorithm and apply it to a recording of music or
#  speech. How many components can you eliminate before the difference is perceptible? 

import matplotlib.pyplot as plt
import numpy as np

from code.thinkdsp import read_wave, Wave
import code.thinkplot as thinkplot

from exercises.lib.lib import play_wave
from exercises.ch_06.ex_1_dct_analyze_run_time import analyze1 as analyze

SOUND_FILE = 'exercises/ch_03/gershwin_rhapsody_in_blue.wav'
FRAMERATE = 88200


def _combine_segments(segments):
    combined_ys = np.array([])
    combined_ts = np.array([])
    for segment in segments:
        combined_ys = np.append(combined_ys, segment.ys)
        combined_ts = np.append(combined_ts, segment.ts)
    return Wave(combined_ys, ts=combined_ts, framerate=FRAMERATE)


def _play_compressed(segment_dcts, compression_ratio):
    print(f'Playing section segments dropping amps <= {compression_ratio * 100}% of mean')
    segments = []
    for segment, _ in segment_dcts:
        seg_copy = segment.copy()
        mean_ys = np.abs(segment.ys).mean()
        threshold = mean_ys * compression_ratio
        seg_copy.ys[seg_copy.ys <= threshold] = 0.
        segments.append(seg_copy)
    wave = _combine_segments(segments)
    play_wave(wave)


def run():
    wave = read_wave(SOUND_FILE)
    start = 0.
    duration_secs = 0.01
    num_segments = int(2. / duration_secs)
    segment_dcts = []
    for i in range(num_segments):
        segment = wave.segment(start, duration_secs)
        spectrum = segment.make_spectrum()
        # segment has ts, an array of time offsets, and ys, the amplitudes at those
        # times. These are the same length. But we get frequencies from the spectrum
        # of the segment, and that has an arbitrary number of entries depending on
        # the Fourier Transform decomposition of the wave, i.e. depending on how many
        # component frequencies there are in the underlying signal.

        # TODO: What is the real way to handle this? In the book he "knows" his
        #  example synthesized audio only has four amplitudes, so he limits ys
        #  and ts to that number of samples:
        #  "But in this case, we know that the ys values were actually generated by
        #  adding only 4 frequency components, so we can use any 4 values from the
        #  wave array to recover amps."
        # fs length is 2x ys and ts, so guess that we should take every other sample
        #  of ys and ts. Lengths off by 1 so trim first sample from fs.
        segment_dcts.append((segment,
                             analyze(segment.ys[::2], segment.make_spectrum().fs[1:],
                                     segment.ts[::2])))
        start += duration_secs

    print('Playing uncompressed full source segment')
    play_wave(wave.segment(0, num_segments * duration_secs))

    compression_ratio = .00001
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .0001
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .001
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .01
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .05
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .1
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .15
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .2
    _play_compressed(segment_dcts, compression_ratio)

    compression_ratio = .5
    _play_compressed(segment_dcts, compression_ratio)


if __name__ == '__main__':
    print("\nChapter 6: ex_2_compression.py")
    print("****************************")
    run()
